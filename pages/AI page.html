<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unicycler Game</title>
    <style>
        body {
            background-color: #f0f0f0; /* Light grey background */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        canvas {
            background-color: #d3d3d3; /* Darker grey for the game area */
            border: 1px solid #000;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="200"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game constants
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 200;
        const GROUND_HEIGHT = 20;
        const UNICYCLER_WIDTH = 30;
        const UNICYCLER_HEIGHT = 50;
        const JUMP_FORCE = -10;
        const GRAVITY = 0.5;
        const OBSTACLE_MIN_WIDTH = 10;
        const OBSTACLE_MAX_WIDTH = 50;
        const OBSTACLE_MIN_HEIGHT = 20;
        const OBSTACLE_MAX_HEIGHT = 50;
        const OBSTACLE_MIN_GAP = 150;
        const OBSTACLE_MAX_GAP = 300;
        const FRISBEE_SIZE = 20;
        const FRISBEE_MIN_HEIGHT = 50;
        const FRISBEE_MAX_HEIGHT = 150;

        // Game state variables
        let unicycler = {
            x: 50,
            y: GAME_HEIGHT - GROUND_HEIGHT - UNICYCLER_HEIGHT,
            vy: 0,
            jumping: false
        };
        let obstacles = [];
        let score = 0;
        let highScore = 0;
        let gameSpeed = 5;
        let isGameOver = false;
        let animationFrame = 0;
        let distanceSinceLastObstacle = 0;
        let nextObstacleGap = OBSTACLE_MIN_GAP + Math.random() * (OBSTACLE_MAX_GAP - OBSTACLE_MIN_GAP);

        // Obstacle constructor
        function Obstacle(x, width, height, type) {
            this.x = x;
            this.y = GAME_HEIGHT - GROUND_HEIGHT - height;
            this.width = width;
            this.height = height;
            this.type = type;
        }

        Obstacle.prototype.draw = function() {
            if (this.type === 'frisbee') {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.fillStyle = this.type === 'curb' ? '#808080' : '#a0a0a0';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        };

        Obstacle.prototype.update = function() {
            this.x -= gameSpeed;
        };

        // Spawn a new obstacle
        function spawnObstacle() {
            const type = Math.random() < 0.2 ? 'frisbee' : Math.random() < 0.5 ? 'curb' : 'can';
            let width, height, x;
            if (type === 'frisbee') {
                width = FRISBEE_SIZE;
                height = FRISBEE_SIZE;
                x = GAME_WIDTH;
                const flyHeight = FRISBEE_MIN_HEIGHT + Math.random() * (FRISBEE_MAX_HEIGHT - FRISBEE_MIN_HEIGHT);
                obstacles.push(new Obstacle(x, width, height, type));
                obstacles[obstacles.length - 1].y = flyHeight;
            } else {
                width = OBSTACLE_MIN_WIDTH + Math.random() * (OBSTACLE_MAX_WIDTH - OBSTACLE_MIN_WIDTH);
                height = OBSTACLE_MIN_HEIGHT + Math.random() * (OBSTACLE_MAX_HEIGHT - OBSTACLE_MIN_HEIGHT);
                x = GAME_WIDTH;
                obstacles.push(new Obstacle(x, width, height, type));
            }
        }

        // Draw the unicycler character
        function drawUnicycler() {
            const yOffset = unicycler.jumping ? 0 : Math.sin(animationFrame * 0.1) * 2;
            ctx.fillStyle = 'red'; // Helmet
            ctx.fillRect(unicycler.x + 10, unicycler.y + yOffset, 10, 5);
            ctx.fillStyle = 'white'; // Shirt
            ctx.fillRect(unicycler.x + 5, unicycler.y + 5 + yOffset, 20, 15);
            ctx.fillStyle = 'blue'; // Jeans
            ctx.fillRect(unicycler.x + 5, unicycler.y + 20 + yOffset, 20, 20);
            ctx.fillStyle = 'black'; // Unicycle frame
            ctx.fillRect(unicycler.x + 12, unicycler.y + 40 + yOffset, 6, 10);
            ctx.beginPath(); // Unicycle wheel
            ctx.arc(unicycler.x + 15, unicycler.y + 55 + yOffset, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Update game state
        function update() {
            if (!isGameOver) {
                animationFrame++;

                // Update unicycler position
                unicycler.vy += GRAVITY;
                unicycler.y += unicycler.vy;
                if (unicycler.y > GAME_HEIGHT - GROUND_HEIGHT - UNICYCLER_HEIGHT) {
                    unicycler.y = GAME_HEIGHT - GROUND_HEIGHT - UNICYCLER_HEIGHT;
                    unicycler.vy = 0;
                    unicycler.jumping = false;
                }

                // Update obstacles
                obstacles.forEach(obstacle => obstacle.update());
                obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);

                // Spawn obstacles based on distance
                distanceSinceLastObstacle += gameSpeed;
                if (distanceSinceLastObstacle > nextObstacleGap) {
                    spawnObstacle();
                    distanceSinceLastObstacle = 0;
                    nextObstacleGap = OBSTACLE_MIN_GAP + Math.random() * (OBSTACLE_MAX_GAP - OBSTACLE_MIN_GAP);
                }

                // Collision detection
                obstacles.forEach(obstacle => {
                    if (
                        unicycler.x + UNICYCLER_WIDTH > obstacle.x &&
                        unicycler.x < obstacle.x + obstacle.width &&
                        unicycler.y + UNICYCLER_HEIGHT > obstacle.y &&
                        unicycler.y < obstacle.y + obstacle.height
                    ) {
                        isGameOver = true;
                        if (score > highScore) highScore = score;
                    }
                });

                // Update score and speed
                score += 1;
                gameSpeed += 0.001; // Gradual speed increase
            }
        }

        // Render the game
        function draw() {
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Draw ground
            ctx.fillStyle = '#a0a0a0';
            ctx.fillRect(0, GAME_HEIGHT - GROUND_HEIGHT, GAME_WIDTH, GROUND_HEIGHT);

            // Draw unicycler and obstacles
            drawUnicycler();
            obstacles.forEach(obstacle => obstacle.draw());

            // Draw scores
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${score}`, 10, 30);
            ctx.fillText(`High Score: ${highScore}`, 10, 60);

            // Game over screen
            if (isGameOver) {
                ctx.fillStyle = 'red';
                ctx.font = '40px Arial';
                ctx.fillText('Game Over', GAME_WIDTH / 2 - 100, GAME_HEIGHT / 2);
            }
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Handle user input
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                if (!isGameOver && !unicycler.jumping) {
                    unicycler.vy = JUMP_FORCE;
                    unicycler.jumping = true;
                } else if (isGameOver) {
                    // Restart game
                    obstacles = [];
                    score = 0;
                    gameSpeed = 5;
                    unicycler.y = GAME_HEIGHT - GROUND_HEIGHT - UNICYCLER_HEIGHT;
                    unicycler.vy = 0;
                    unicycler.jumping = false;
                    isGameOver = false;
                    nextObstacleGap = OBSTACLE_MIN_GAP + Math.random() * (OBSTACLE_MAX_GAP - OBSTACLE_MIN_GAP);
                    distanceSinceLastObstacle = 0;
                }
            }
        });

        // Start the game
        gameLoop();
    </script>
</body>
</html>